---
title: "R tutorial"
author: "Michael C. Jeziorski"
date: "19 August 2024"
output:
  html_document: 
    toc: yes
    toc_depth: 2
    toc_float: 
      collapsed: no
    theme: cerulean
    df_print: kable
editor_options: 
  chunk_output_type: inline
---
<style type="text/css">

code.r{ /* Code block */
    font-size: 12px;
    font-family-monospace: Monaco;
}

</style>

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, results = "markup")
library(tidyverse)
```


# Introduction  <img style="float: right;" src="images/Rlogo.jpg">

### What is R?

R is a programming language widely used by scientists to organize, analyze, and visualize data.  It is free and open source, and many packages have been developed to allow researchers to work with particular types of data.

### Why does R have such a bad name?

R is derived from the language S, which also has an unhelpful name that was created by people who never expected search engines to be important.  R was developed by Ross Ihaka and Robert Gentleman, so you can guess why they used the name R.  (Fortunately, it is not that difficult to use search engines to find help with R.)

### Why should I learn R?

R is designed to be user-friendly to researchers who have relatively little programming experience.  Along with Python, R is the language of choice in the biological sciences, and a great number of analysis packages have been written for researchers.

In addition, data science is increasingly important not only in biomedicine, but in a great many fields involving the analysis and visual presentation of data.  Knowing the basics of a data science language gives the user a powerful set of tools that can be used in health sciences, finance, public policy, sports... practically any field that generates data.

### The great benefits of learning an open-source data science language

* Free to obtain and use
* Many free tutorials and resources are available
* Can be used to analyze virtually any dataset
* Completely portable
* Convenient for remote work
* Businesses will pay money to have data analyzed
* Large support communities

### Is R the only language I need to do bioinformatic analysis?

A shell program such as bash that interacts with Linux is the best way to handle huge datafiles like the raw files generated by next-generation sequencing, processing of which requires intensive CPU usage, and familiarity with bash/Linux commands is always useful for a data scientist.  However, R complements Linux well and is easier to use.  You will often do initial processing of a dataset with the shell command line and then move it to R for further analysis and visualization.

### I already use Excel for my data.  Can I just keep using that?

Excel is a convenient and user-friendly way to work with data, but it was not developed with scientists in mind.  Excel also allows great freedom in how data are entered, which can cause problems with further analysis.  If you are working with a table that has a few entries or a few hundred, you may continue to find Excel useful.  Once a dataset reaches a larger size, R becomes a much better option to handle the data, and its visualization tools are stronger than those of Excel.  

### What is better to learn, R or Python?

That question is like asking whether it is better to learn French or German.  It all depends on where you are working and who you will work with.  In data science, Python is more widely used than R.  However, many researchers in the biological sciences have chosen to work with R.  If you are gifted at programming languages, you can try to learn both.  After learning R to an intermediate level, I took classes in Python, but found that my time was better spent becoming stronger in R than intermediate in two languages.  

### How do I use R?

R can be installed on a computer running Windows, MacOS, or Linux.  It is downloaded at no cost from the [Comprehensive R Archive Network (CRAN)](https://www.r-project.org/).  R can be run as a command-line program.  However, this course will use RStudio to run R.  New versions of R are released every few months, and the latest version of R is 4.4.0, which all participants should have installed.  

### What is RStudio?

[RStudio](https://posit.co//) is an integrated development environment (IDE), a software package that works as an interface between R and the user to make R far more user-friendly and flexible.  RStudio is free for individual users to download and use; the latest version is 2024.04.1+748.  In this course we will see the many benefits to using RStudio.  RStudio does not include R itself, so the two software packages must be downloaded and installed separately.  

### Can data be transferred between R and other programs?

R is intended to be friendly with other programs, and there are packages that will allow you to import Excel files, text, .csv files, and many other filetypes, including those used in bioinformatics.  Data can be exported from R and images saved in standard file formats.  R packages for biologists facilitate interaction with GenBank, EMBL, and other databases.  RStudio is also designed to be used with other languages, including Python.  

### What is an R package?

The distribution of R initially installed on your computer is known as "base R", and it includes a set of commands to organize and visualize data.  These commands are useful but limited, and packages have been developed to expand on them.  Such packages can be installed and loaded within R to give the user a greater range of options.  Packages are particularly important in bioinformatics, and in many of the analyses in this course, we will start by loading packages that will facilitate how we work with R.  Like R and RStudio, packages are free to download and use.  

To install a package, use the command  
`install.packages("<package_name>")`  
This needs to be done only once.

To load a package into the current working environment, use  
`library(<package_name>)`  
This needs to be done each time you start a new session, and generally should be at the start of your script.

If you want to use a function that is part of an installed package but you do not want to load the entire library, you can use the syntax `package_name::function()`.  This syntax is also useful when you are explaining a workflow to another user who may not have all the packages loaded and needs to know which packages are being implemented.

### What can be created with R?

* vectors and lists
* tables
* functions
* statistical analyses
* workflows
* data repositories
* graphs
* interactive graphs
* reports  
* documents for publication  
* slideshow presentations  
* maps  
* web applications that users can interact with  

The tutorial you are reading was created in R using RMarkdown.

### What is RMarkdown?

Markdown is a simple language used to format plain text documents to add features like bold or italic text, different font sizes, headings, bulleted lists, and so on.  RMarkdown is the R version of Markdown, and allows the user to not only organize data and view graphs in R, but to write text that can be integrated with the data and graphs to produce a final, readable document.

After many years of using R, I learned that R Markdown is not only useful, but is the best way to work with R.  It gives you the ability to transform your workflow directly into a document in Word, slide, or PDF format that can easily be updated with new data.  It also allows you to break up your code in logical ways so that only the "chunks" of code that you want to update are run again.

### How is RMarkdown used?

Here we will see some examples of RMarkdown.

### What is an R project?

RStudio allows the user to create projects, which are like notebooks that contain the working environment for a particular experiment or workflow.  By opening a project you open all the documents and objects that were in use the last time you closed the project.  This way of working with your various tasks makes organization easier.

### How does the instructor of this course use R?

* I always work with R inside RStudio.  
* For each new research project I create a new R project in RStudio, which allows me to keep different work separated and organized.  
* I always write my code in RMarkdown files.
* The [tidyverse](https://www.tidyverse.org/packages/) is a suite of packages created by the people behind RStudio that are designed to make R easier and more intuitive.  I use tidyverse instead of base R whenever possible.  
* After importing data, I save the initial dataset as a raw file and work with a modified version under a different name, so I can recover the original data if necessary.  
* When creating an object, I use names that are short, easy to read, consistent, and informative.  For readability, I use an underline character to separate words (`my_file`), while others may use `my-file` or `myFile`.
* I try to reduce the number of objects created in the workspace.  
* I add informative comments to my code as much as possible to help me later, knowing how frustrating it is to not remember what I was doing a year ago.  Comments are preceded by a hashtag (`#`).
* I want my code to be easily read, so I use spaces and indentation in consistent ways.  
* I prefer open-source software to licensed and often expensive software.  
* Many help resources are available online.
* When working with code, plagiarism is encouraged!

***

# RStudio  <img style="float: right;" src="images/RStudio-Logo-Blue-Gray-125.png">

## Advantages of RStudio

* Ease of use  
* Availability of information  
* Organization  
* Flexibility  
* Reproducibility

## RStudio layout

### Console pane
The console pane is where R code is executed and output is generated.  You can enter code directly in the console pane or compose it in the script pane and then run it.

### Script pane
The script pane contains code to be executed.  Code can be run line by line or an entire script can be run at once.  If you plan to run a line of code more than once, it is best to include it in a script, which can be saved and edited.  The script pane is also for R markdown or R notebook files and is where dataframes can be viewed.

### Environment pane
The environment pane shows the objects that are currently loaded in the working environment.  Each time you create a new object, that object appears in the environment pane with some details about its contents.  In addition to the environment window, a history tab shows the history of executed commands.

### File/plot/help pane
The fourth pane has several tabs.  One shows the files available in the current working directory.  Another tab displays plots and a third shows HTML output.  The packages tab shows packages available for use.  Finally, the help tab provides documentation for R commands.

***

# Basic R elements

## Pay close attention

* UPPERCASE vs. lowercase  
* Close every parenthesis: `( )`  
* A line of code can continue on the next line, but the second line should be indented  
* Do not overwrite a variable unless you are certain you want to  
* Use object names that are clear and contain only letters, numbers, and a separator of your choice (no spaces)
* R uses 1-based indexing: the first element of a vector or list is in position 1

## Comments
A comment in R code is preceded by a hashtag (#).  Any text on the line after that symbol will not be executed.  Comments are highly useful and strongly recommended for providing information about what your code is intended to do.  Your memory is not as good as you think it is, so leave notes for yourself and others!
```{r}
# This is 3 plus 3.
3 + 3  # A comment can be on the same line as code that is executed.
```

## Arithmetic
Arithmetic operations can be executed directly in the console.
```{r}
2 + 5
2 - 1
3 * 4
7 / 6
3 ^ 3
```
## Comparisons
```{r}
4 == 3  # Note that to compare if two things are equal, a double equal sign is used.
4 > 3   # greater than
4 >= 3  # greater than or equal to
4 < 3   # less than
4 <= 3  # less than or equal to
4 != 3  # not equal to
```
## Logical connectors
```{r}
4 > 3 & 4 < 3  # Is 4 greater than 3 AND 4 less than 3?
4 > 3 | 4 < 3  # Is 4 greater than 3 OR 4 less than 3?
```

## Creating objects
Objects are created in R using the assignment operator, made up of two characters together without a space, `<-`  
`object_name <- value` or `operation`  
The equal sign (`=`) can also be used, but is not recommended because it is used for other operations.  The name of an object can be made up of letters, numbers, and `-` or `_`, but must begin with a letter.  Names of functions like `mean` should not be used as names of objects.  All spelling in R is case-dependent, so "apple" and "Apple" are different words.  

While this operation shows the result in the console
```{r}
18 + 73
```
this operation stores the result in an object.
```{r}
sum1 <- 18 + 73
```
Arithmetic operations can be executed on objects that are numbers.
```{r}
sum1 + 45
sum1 * sum1
```

***

# Basic types of objects

## Atomic datatypes
The basic datatypes in R include:  
**integer**: `8`, `4`, `23`  
**numeric** or **double**: `9.2`, `0.888`  
**character**: `"Mexico"`, `"sol"`, `"luna"` (always within either double or single quotation marks)  
**factor**: `"control"`, `"treatment"` (like character, but with defined levels)  
**logical**: `TRUE`, `FALSE`  (spelled out in all caps, no quotation marks)  
**complex**: `3 + 4i`

Special values:  
**missing value**: `NA`  
**infinity**: `Inf`  
**not a number**: `NaN`

## Values
An object can contain a single value, which is more accurately a vector of length 1.
```{r}
val1 <- 8
val2 <- "yellow"
val3 <- TRUE
```
The contents of an object can be seen by entering its name into the console.
```{r, eval = TRUE, echo = TRUE}
val1
```
The class, or datatype, of an object can be viewed using `class()`.
```{r}
class(val1)
class(val2)
class(val3)
```
An object can also store the result of an operation.
```{r}
val4 <- 9 + 13
val4
```
An object can be on both sides of the operation and will be overwritten with the new value.  This can be both convenient and dangerous because the previous value is erased.
```{r}
val4
val4 <- val4 + 5
val4
```
For operations to work, the datatypes need to be compatible.
```{r}
# val1 + 5  this will work because val1 is an integer
# val2 + 5  this will cause an error because val2 is a character object
```
R will make logical assumptions about datatypes.  Values can be coerced to another type.
```{r}
val1
as.character(val1)
```

## Vectors
An object can also be a vector of more than one value.  Combining two or more values is done by using the `c()` command.
```{r}
# A sequence of numbers can be generated by using :
vec1 <- 1:40
vec1
# Other vectors can be made using the c() command to combine multiple values.
vec2 <- c(1.3, 2.9, 6.6, 3.0, 8.4)
vec2
```
Values in a vector must be of the same type.  If values are of different types, R will coerce them to be the same type.  If R cannot coerce, it will replace the value with `NA`.
```{r}
vec3 <- c(1, "blue", 9)
vec3
```
An empty vector can be defined using the `vector()` function.
```{r}
vec4 <- vector("numeric", length = 10)
vec4
```
If a vector contains integers or numeric data, arithmetic operations can be executed on it.
```{r}
vec1
vec1 / 4
```
Functions in R can also work on vectors.
```{r}
mean(vec1)
sum(vec1)
```
Logical operations can work on vectors.
```{r}
vec2
vec2 > 3
vec2 >= 3
```
An element of a vector is extracted using the position number of the element inside single brackets: `[ ]`.  Consecutive elements are extracted by using the start and end position separated by `:`.  Nonconsecutive elements require the `c()` function.
```{r}
vec2[2]
vec2[2:5]
vec2[c(2, 4)]
```
A vector can also be subsetted by using a logical operation, extracting the elements for which the condition is `TRUE`.
```{r}
vec2 < 4
vec2
vec2[vec2 < 4]
vec2[vec2 >= 4]
```
## Lists
Unlike vectors or matrices, lists can contain different datatypes.  Lists can even contain other lists.  As such, they can have a complex structure.
```{r}
list1 <- list("a", 1, 6.3)
list1
```
Notice the more separated organization of lists.
```{r}
list2 <- list(18, list1, c("G", "A", "T", "C"))
list2
```
Due to their complex structure, lists are subsetted differently from vectors.  Single brackets will extract elements as lists, while double brackets can extract elements as other datatypes.
```{r}
list2[1]         # extract the first element of list2 as a list
class(list2[1])
list2[[1]]       # extract the first element of list2 as a value
class(list2[[1]])
list2[3]         # extract the third element of list2 as a list
list2[[3]]       # extract the third element of list2 as a vector
list2[[3]][1:2]  # extract a subset of the third element
```

## Matrices
Matrices are two-dimensional sets of data consisting of columns and rows in which all of the values are of a single type (e.g. numeric).  Much bioinformatic data is created in matrices (usually numeric), which can affect how it is read into R.

```{r}
mat1 <- matrix(c(1:4, 11:14, 21:24), nrow = 4, ncol = 3, byrow = FALSE)
mat1
rownames(mat1) <- c("gene1", "gene2", "gene3", "gene4")
colnames(mat1) <- c("expt1", "expt2", "expt3")
```

The elements of a matrix can be extracted using the syntax `matrix_name[row_number, col_number]`.

```{r}
mat1[1, ]
mat1[, 2]
mat1[4, 3]
mat1[2:3, ]
```

## Dataframes
Like matrices, dataframes are datasets with rows and columns.  Unlike matrices, dataframes can have multiple datatypes such as integer and character, although every column has a defined datatype.  As such, a dataframe most closely resembles data in an Excel spreadsheet, although one that is perfectly rectangular.  Because dataframes can contain different datatypes, they are a special kind of list, a list of vectors (columns) in which each vector has the same length.
```{r}
df1 <- data.frame(x = 1:3, y = c("a", "b", "c"), z = c(TRUE, TRUE, FALSE))
df1
```
Because dataframe columns must all be of the same length, missing data will be replaced by `NA`.
```{r}
dim(df1)  # to see the dimensions of a dataframe (rows, columns)
str(df1)  # to see details about the columns of a dataframe
summary(df1)  # to get some summary statistics for the columns
```
Data can be extracted from dataframes in various ways.  Like matrices, dataframes can be subsetted using the syntax `df_name[row_number, col_number]`.
```{r}
df1[1, ]  # extract the first row from df1 as a dataframe
df1[, 3]  # extract the third column from df1
df1[2, 3] # extract the value in the second row, third column

```
A column can be extracted from a dataframe using the `$` operator.  Logical values can also be used to extract.
```{r}
df1$x     # extract the column named "x" from df1 as a vector
df1[df1$x == 2, ]  # extract the row where x = 2
df1[df1$z == TRUE, ]  # extract the rows where z = TRUE
```
The column names can be seen or modified using `colnames()`.
```{r}
colnames(df1)
bind_cols(df1, d = 4:6)
colnames(df1) <- c("a", "b", "c")
df1
df1$x    # no longer works due to renaming!
```
Values within a dataframe can be overwritten.
```{r}
df1
df1[2, 3] <- NA
df1
```

***

# Functions

R has a number of built-in functions, while other functions are contained within packages.  In addition, users can create their own functions.  Functions are composed of the function name followed by parentheses in which arguments are provided, either mandatory or optional.  Some functions can work without arguments.  For example, the following function shows the current date and time:
```{r eval = FALSE}
date()
```
An example of a function that requires an argument is `mean()`.  If we look at the help page for `mean()`, the structure of the command is:  
`mean(x, trim = 0, na.rm = FALSE, ...)`  
`x` is a mandatory object, the data for which the mean is calculated.  The remaining arguments are optional and have their default values shown.  We do not need to define them unless the default value is not desired.
```{r}
sample1 <- c(8, 12, 5, 13, 7)
mean(sample1)
# If the vector contains NA values, mean() returns NA.
sample2 <- c(8, 12, 5, 13, 7, NA)
mean(sample2)
# We can define the na.rm argument (remove NA) to ignore NA values.
mean(sample2, na.rm = TRUE)
```
User-defined functions are created using the `function()` command and curly braces `{}`.  If we want to write a function to calculate the length of the hypotenuse of a right triangle given the lengths of the two sides, the syntax is:
```{r}
hyp <- function(side1, side2) {
      sqrt((side1 ^ 2) + (side2 ^ 2))
}
hyp(3, 4)
hyp(5, 12)

```
`hyp(12)` returns an error because the function requires two arguments.

***

# The tidyverse package suite  <img style="float: right;" src="images/tidyverse-200x231.png">

Many bioinformatics workflows you will encounter will use the syntax of base R.  The base R functions are universally available.  However, many of them are not intuitive to learn or use.  The `tidyverse` family of packages were created by Hadley Wickham and collaborators to provide a large number of functions that work well together to powerfully manipulate data.

* readr - to read in two-dimensional data  
* tidyr - for data organization  
* dplyr - for data manipulation  
* tibble - a modified approach to dataframes  
* stringr - to work with character strings  
* ggplot2 - for graphics  
* forcats - for factors
* purrr - to work with functions, vectors, and lists

We will work with dplyr commands to manipulate data and ggplot2 to visualize it.  We can load each package separately, but loading the tidyverse is easier.
```{r message = FALSE}
library(tidyverse)
```
Although tidyverse commands can be used with a variety of objects, it is designed to work on dataframes.  The commands are intended to manipulate a two-dimensional data table, much like what we typically encounter in Excel.  However, the way in which the tidyverse functions requires a profound re-thinking of how we organize our data.

The tidyverse works on the premise of "tidy data".  For a dataframe, tidy data means that each row is an observation and each column a variable.  A common challenge we face in data science is untidy data: inconsistent values, incorrect datatypes, or missing values.  Much of the work with such data is in cleaning it up for downstream analysis.

R provides a variety of preloaded datasets for users to practice with; a list can be seen by typing `data()` into the console.  We will be using the `mtcars` dataset that contains data from *Motor Trend* magazine in 1974 for 32 different models of cars, and is a useful dataset to manipulate and visualize.  To see the contents of the `mtcars` dataset, type `?mtcars`.

# dplyr functions
* `%>%` - the pipe operator, similar to `|` in Linux
* `select` - choose columns  
* `filter` - choose rows based on conditions  
* `arrange` - sort rows based on column values  
* `mutate` - convert data in an existing column into new data in a new column  
* `summarize` - provide summary data for a column  
* `group_by` - group data based on a variable; often used with summarize

We have several ways to get an idea of the structure and contents of a dataset.
```{r}
head(mtcars)       # to see the first six lines
str(mtcars)        # to see the structure, including dimensions
summary(mtcars)    # to see summary statistics of each column
glimpse(mtcars)    # this is the dplyr version of str()
```
## Pipe operator
One benefit of dplyr is the use of the pipe operator `%>%`, which is possible because the dplyr functions integrate well with each other.  As in Linux, the pipe tells R to treat the output from the previous command as input to the next command.  We will first examine some of the dplyr functions, then see how they can be linked together.

## `mutate`
The `mutate` function allows us to create new data columns from existing columns.  If we want to convert mpg (miles per gallon) to kilometers per liter, we can add a data column.  The syntax is  
`mutate(df, new_column = function(column))`
```{r}
mutate(mtcars, kmpl = mpg * 0.425)
```
Another use of `mutate` can address the difference between the output of base R commands and dplyr commands above.  The mtcars dataframe uses the names of the cars as row names.  This practice is discouraged by dplyr, so the output of dplyr commands lacks the car names.  We can resolve this issue by making a new dataframe with the names as a column.  The `mutate` function allows us to do this.
```{r}
mtcars_new <- mutate(mtcars, cars = rownames(mtcars))  # creates a new column from the names of the rows
rownames(mtcars_new) <- 1:length(mtcars_new$mpg)  # the length function gives the number of rows, so we don't need to count
head(mtcars_new)
str(mtcars_new)
```
## `select`
The `select` function allows us to select columns by name or position.  The syntax is  
`select(df, column_name(s))`  
where `df` is the dataframe.  Columns can be selected by name or by position number; this is a quick way to reorder the columns as well.  `select()` offers multiple ways to identify desired columns.
```{r}
select(mtcars_new, 12, 1:11)                        # dplyr
mtcars_new <- select(mtcars_new, cars, mpg:carb)    # dplyr; recommended because columns are named
select(mtcars_new, cars, cyl:vs, gear)              # use : to select consecutive columns
select(mtcars_new, -vs)                             # use - to eliminate a column and keep the others
```
## `filter`
The `filter` function filters rows based on criteria.
`filter(df, condition, optional_second_condition)`
```{r}
filter(mtcars_new, cyl == 4)                     # dplyr
filter(mtcars_new, cyl == 4, am == 1, mpg > 25)  # filter based on multiple columns
```
If we want to define multiple criteria for one column, we can do so using the `%in%` operator.  The following returns all cars with either 4 or 8 cylinders.
```{r}
filter(mtcars_new, cyl %in% c(4, 8))
```
## `arrange`
The `arrange` function sorts the table based on one or more columns.  Use `desc()` to sort in descending order.  This replaces `sort()` in base R.  
`arrange(df, column, optional_second_column)`
```{r}
arrange(mtcars_new, desc(mpg))          # sort by mpg in descending order
arrange(mtcars_new, cyl, desc(mpg))     # sort by cyl, then mpg in descending order
```

## `group_by` and `summarize`
These two commands are often used together, and will be our first look at how the pipe operator can be used to chain commands.  `group_by` will separate the data into groups based on a column, and `summarize` can then perform operations on each group.

For example, `group_by` and `summarize` can be used together to generate mean mpg for cars of 4, 6, and 8 cylinders.
```{r}
group_by(mtcars_new, cyl) %>%               # group data by number of cylinders
      summarize(mean_mpg = mean(mpg))       # THEN find the mean mpg for each group
```
The pipe operator tells R to take the result of the `group_by` command as the input to the summarize command.  We can even use the dataframe as the initial input to the pipe, allowing functions to be simpler.
```{r}
mtcars_new %>%
      group_by(cyl) %>%               
      summarize(mean_mpg = mean(mpg), mean_hp = mean(hp))   
```
Piping functions together can be quite powerful.  Suppose we wanted to start with the `mtcars` dataset and print out only the names and kmpl of all 4-cylinder cars in descending order.  In base R, this would potentially involve creating several intermediate objects: a table with only 4-cylinder cars, then a sorted table, then selecting the columns.  dplyr allows us to do the same task with a single command using pipes, so intermediate objects do not need to be created.
```{r}
# base R
mtcars_new_baseR <- mtcars
mtcars_new_baseR["kmpl"] <- mtcars["mpg"] * 0.425
mtcars_new_baseR <- rownames_to_column(mtcars_new_baseR, var = "cars")
mtcars_new_baseR <- mtcars_new_baseR[order(mtcars_new_baseR$kmpl, decreasing = TRUE), ]
mtcars_new_baseR[, c(1, 13)]

# tidyverse
mtcars %>%                                      # start with the original dataset
      mutate(cars = rownames(mtcars)) %>%       # FIRST create a new column from the row names
      as_tibble() %>%                           # THEN convert to tibble (drop rownames)
      mutate(kmpl = mpg * 0.425) %>%            # THEN create the kmpl variable from mpg
      filter(cyl == 4) %>%                      # THEN filter the models with 4 cylinders
      arrange(desc(kmpl)) %>%                   # THEN sort by kmpl, largest to smallest
      select(cars, kmpl)                        # THEN show only the names and kmpl
```
Now if we want to do the same for 8-cylinder cars, we simply change one number in the command.  No extra objects are being created. If the output is what we want, we can modify the command to assign the output to an object.
```{r}
mtcars %>%                                        # check output in console
      mutate(cars = rownames(mtcars)) %>%
      filter(cyl == 8) %>%                   
      arrange(desc(mpg)) %>%              
      select(cars, mpg)

mtcars_8_cyl <- mtcars_new %>%                        # save output to object
      mutate(cars = rownames(mtcars)) %>%
      filter(cyl == 8) %>%                   
      arrange(desc(mpg)) %>%              
      select(cars, mpg)               
```

***

# Visualizing data with ggplot2  <img style="float: right;" src="images/ggplot2-200x232.png">
Another benefit of the tidyverse is that dplyr functions work well with ggplot2, the tidyverse graphing package.  The gg stands for "grammar of graphics", and ggplot2 is built on concepts of data visualization that allow a great number of possibilities.  Furthermore, the output of ggplot2 commands can be saved as objects, allowing them to be easily modified.

In ggplot2, we start by defining the "aesthetics", which are graph features on which we can map variables.  The most basic aesthetics are the x and y axes.  In the first line the dataset and aesthetics are defined, and then visualization options are added using the `+` operator.  For a scatterplot we use `geom_point()`; `geom` refers to the type of visualization layer.
```{r}
ggplot(mtcars_new, aes(x = hp, y = mpg)) +
      geom_point()
```

The graph is quite simple, but we can make it more interesting by adding aesthetics.  We will color the points by number of cylinders (`cyl`).
```{r}
ggplot(mtcars_new, aes(x = hp, y = mpg, color = cyl)) +
      geom_point()
```

The graph looks strange because ggplot is treating `cyl` as a continuous variable.  We know it to be discrete; no car has a fraction of a cylinder.  We can tell ggplot to treat the `cyl` variable as a factor with discrete levels using `as.factor()`.
```{r}
ggplot(mtcars_new, aes(x = hp, y = mpg, color = as.factor(cyl))) +
      geom_point()
```

We can keep adding aesthetics.  Engine displacement (`disp`) can be mapped to point size.
```{r}
ggplot(mtcars_new, aes(x = hp, y = mpg, color = as.factor(cyl), size = disp)) +
      geom_point()
```

Axis labels, legend, and other features can be customized.  For example, points can be made more transparent using the `alpha` argument to `geom_point`.
```{r}
ggplot(mtcars_new, aes(x = hp, y = mpg, color = as.factor(cyl), size = disp)) +
      geom_point(alpha = 0.5) +
      labs(x = "Horsepower", y = "Miles per gallon", 
           title = "Horsepower vs. fuel effiency for 1974 cars", 
           color = "cylinders", size = "displacement")
```

As we make the plot look better, we can save it as an object, then work with that object.
```{r}
mygraph <- ggplot(mtcars_new, 
                  aes(x = hp, y = mpg, color = as.factor(cyl), size = disp)) +
      geom_point() +
      labs(x = "Horsepower", y = "Miles per gallon", 
           title = "Horsepower vs. fuel effiency for 1974 cars", 
           color = "cylinders", size = "displacement")
```

We can pipe using the dplyr `%>%` operator straight into ggplot, meaning we can easily graph a subset of our data.  For example, we can filter to view only cars with manual transmissions, defined by the variable `am == 0`.  
```{r}
# am == 1 denotes cars with manual transmission
mtcars_new %>%
      filter(am == 1) %>%
      ggplot(aes(x = hp, y = mpg, color = as.factor(cyl), size = disp)) +
      geom_point()
```

If the default settings are not appealing, we have many formatting options, including preset themes.
```{r}
mygraph +
      theme_classic()
```

Two plots side by side, separated into automatic and manual transmissions.
```{r}
mygraph +
      facet_grid(. ~ am, labeller = as_labeller(c(`0` = "Automatic", `1` = "Manual")))  # this creates a plot for each level of am
      
```

What do these graphs tell us about the characteristics of automatic and manual transmissions?

